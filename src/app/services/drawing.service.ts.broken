import { Injectable } from '@angular/core';
import * as fabric from 'fabric';
import { IsometryService } from './isometry.service';
import { LineDrawingService } from './line-drawing.service';
import { DimensionService } from './dimension.service';
import { ObjectManagementService } from './object-management.service';
import { WeldingService } from './welding.service';
import { StateManagementService } from './state-management.service';
import { PipingService } from './piping.service';
import { IsometryToolsService } from './isometry-tools.service';
import { ExportService } from './export.service';
import { RenderSchedulerService } from './render-scheduler.service';
import { FreehandDrawingService } from './freehand-drawing.service';
import { BehaviorSubject } from 'rxjs';

// Central type for all drawing modes
export type DrawingMode = 'idle' | 'addLine' | 'addPipe' | 'dimension' | 'text' | 'addAnchors' | 
  'weldstamp' | 'welderstamp' | 'welderstampempty' | 'welderstampas' | 'weld' | 'fluidstamp' | 
  'spool' | 'flow' | 'gateValve' | 'gateValveS' | 'gateValveFL' | 'globeValveS' | 'globeValveFL' | 
  'ballValveS' | 'ballValveFL' | 'teeJoint' | 'slope' | 'testLine' | 'freehand' | 'movePipe';

// Global counter to track DrawingService instances
let instanceCounter = 0;

@Injectable({
  providedIn: 'root',
})
export class DrawingService {
  private redrawRequest = new BehaviorSubject<void>(undefined);
  redraw$ = this.redrawRequest.asObservable();
  private canvas!: fabric.Canvas;
  private instanceId: number;
  
  // Color mode management
  public colorMode: 'drawing' | 'blackwhite' | 'norm' = 'drawing';
  
  // Color schemes for different modes
  private colorSchemes = {
    drawing: {
      line: 'black',
      pipe: 'green',
      dimension: 'blue',
      text: 'black',
      weld: 'red',
      anchor: 'rgba(128, 128, 128, 0.5)',
      valve: '#2563eb'
    },
    blackwhite: {
      line: 'black',
      pipe: 'black',
      dimension: 'black',
      text: 'black',
      weld: 'black',
      anchor: 'rgba(0, 0, 0, 0.5)',
      valve: 'black'
    },
    norm: {
      // DIN ISO 6412-2 standard colors for isometric piping
      line: '#000000',      // Black for general lines
      pipe: '#00A050',      // Green for process pipes
      dimension: '#0000FF', // Blue for dimensions
      text: '#000000',      // Black for text
      weld: '#FF0000',      // Red for welds
      anchor: 'rgba(128, 128, 128, 0.3)',
      valve: '#800080'      // Purple for valves
    }
  };

  constructor(
    private isometryService: IsometryService,
    private lineDrawingService: LineDrawingService,
    public dimensionService: DimensionService,
    private objectManagementService: ObjectManagementService,
    private weldingService: WeldingService,
    private stateManagementService: StateManagementService,
    private pipingService: PipingService,
    private isometryToolsService: IsometryToolsService,
    private exportService: ExportService,
    private renderScheduler: RenderSchedulerService,
    public freehandDrawingService: FreehandDrawingService
  ) {
    this.instanceId = ++instanceCounter;
    console.log(`DrawingService instance #${this.instanceId} created`);
    // Connect state management to services
    this.lineDrawingService.setStateManagement(this.stateManagementService);
    this.dimensionService.setStateManagement(this.stateManagementService);
    this.weldingService.setStateManagement(this.stateManagementService);
    this.objectManagementService.setStateManagement(this.stateManagementService);
    this.pipingService.setStateManagement(this.stateManagementService);
    this.isometryToolsService.setStateManagement(this.stateManagementService);
    this.freehandDrawingService.setStateManagement(this.stateManagementService);
    
    // Connect drawing service for color management
    this.lineDrawingService.setDrawingService(this);
    this.isometryToolsService.setDrawingService(this);
    
    // Connect piping service to line drawing service for pipe segment tracking
    this.pipingService.setLineDrawingService(this.lineDrawingService);
  }

  public setCanvas(canvas: fabric.Canvas): void {
    console.log(`DrawingService #${this.instanceId}.setCanvas called with canvas:`, !!canvas);
    this.canvas = canvas;
    this.lineDrawingService.setCanvas(canvas);
    this.weldingService.setCanvas(canvas);
    this.pipingService.setCanvas(canvas);
    this.isometryToolsService.setCanvas(canvas);
    this.exportService.initializeCanvas(canvas);
    this.freehandDrawingService.setCanvas(canvas);
    console.log(`DrawingService #${this.instanceId} canvas is now set:`, !!this.canvas);
  }

  public requestRedraw(): void {
    this.redrawRequest.next();
  }

  public getCanvas(): fabric.Canvas {
    console.log(`DrawingService #${this.instanceId}.getCanvas called, canvas exists:`, !!this.canvas);
    return this.canvas;
  }

  public isEditingText(): boolean {
    return this.objectManagementService.isEditingText(this.canvas);
  }

  public isTextEditingInGroup(): boolean {
    const activeObject = this.canvas?.getActiveObject();
    if (activeObject && activeObject.type === 'group') {
      const group = activeObject as fabric.Group;
      let isEditing = false;
      group.forEachObject((obj: fabric.Object) => {
        if (obj.type === 'i-text' && (obj as fabric.IText).isEditing) {
          isEditing = true;
        }
      });
      return isEditing;
    }
    return false;
  }

  public startDimensioning(): void {
    this.lineDrawingService.setDrawingMode('dimension');
    this.dimensionService.startDimensioning();
    this.canvas.discardActiveObject();
    this.canvas.requestRenderAll();

    // Prepare dimensionable anchors from editable pipes and lines
    const editablePipes = this.lineDrawingService.getEditablePipes();
    const editableLines = this.lineDrawingService.getEditableLines();
    this.dimensionService.prepareDimensionableAnchors(this.canvas, editablePipes, editableLines);
    
    // Stelle sicher, dass alle Ankerpunkte sichtbar bleiben
    this.dimensionService.ensureAnchorsAlwaysVisible(this.canvas);
  }
  
  public startIsoDimensioning(): void {
    if (!this.canvas) {
      console.warn('Canvas not ready, cannot start ISO dimensioning');
      return;
    }
    this.lineDrawingService.setDrawingMode('dimension');
    this.dimensionService.startIsoDimensioning();
    this.canvas.discardActiveObject();
    this.canvas.requestRenderAll();

    // Prepare dimensionable anchors from editable pipes and lines
    const editablePipes = this.lineDrawingService.getEditablePipes();
    const editableLines = this.lineDrawingService.getEditableLines();
    this.dimensionService.prepareDimensionableAnchors(this.canvas, editablePipes, editableLines);
    
    // Stelle sicher, dass alle Ankerpunkte sichtbar bleiben
    this.dimensionService.ensureAnchorsAlwaysVisible(this.canvas);
  }

  public startTextMode(): void {
    this.lineDrawingService.setDrawingMode('text');
  }

  public setDrawingMode(mode: DrawingMode): void {
    console.log(`DrawingService #${this.instanceId}.setDrawingMode called with:`, mode);
    console.log(`DrawingService #${this.instanceId} Canvas available:`, !!this.canvas);
    
    // If canvas is not ready yet, just return
    if (!this.canvas) {
      console.warn('Canvas not ready, cannot set drawing mode');
      return;
    }
    // Stop dimension mode if it was active and we're switching to a different mode
    if (this.lineDrawingService.drawingMode === 'dimension' && mode !== 'dimension') {
      if (this.canvas) {
        this.dimensionService.resetAnchorHighlights(this.canvas);
      }
      this.dimensionService.stopDimensioning();
    }
    
    if (mode === 'weldstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWeldstamp();
    } else if (mode === 'welderstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStamp();
    } else if (mode === 'welderstampempty') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStampEmpty();
    } else if (mode === 'welderstampas') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStampAS();
    } else if (mode === 'weld') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWeld();
    } else if (mode === 'fluidstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startFluidStamp();
    } else if (mode === 'spool') {
      this.lineDrawingService.setDrawingMode('spool');
      this.objectManagementService.startSpoolMode();
    } else if (mode === 'flow') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startFlowMode();
    } else if (mode === 'gateValve') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveMode();
    } else if (mode === 'gateValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveSMode();
    } else if (mode === 'gateValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveFLMode();
    } else if (mode === 'globeValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGlobeValveSMode();
    } else if (mode === 'globeValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGlobeValveFLMode();
    } else if (mode === 'ballValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startBallValveSMode();
    } else if (mode === 'ballValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startBallValveFLMode();
    } else if ((mode as any) === 'teeJoint') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startTeeJointMode();
    } else if (mode === 'slope') {
      this.lineDrawingService.setDrawingMode('idle');
      this.isometryToolsService.startSlopeMode();
    } else if (mode === 'testLine') {
      this.lineDrawingService.setDrawingMode('testLine');
    } else if (mode === 'freehand') {
      this.lineDrawingService.setDrawingMode('idle');
      this.freehandDrawingService.startFreehandDrawing();
    } else {
      console.log('Entering else clause for mode:', mode);
      this.weldingService.stopWeldstamp();
      this.weldingService.stopWelderStamp();
      this.weldingService.stopWelderStampEmpty();
      this.weldingService.stopWelderStampAS();
      this.weldingService.stopWeld();
      this.weldingService.stopFluidStamp();
      this.objectManagementService.stopSpoolMode();
      this.pipingService.stopFlowMode();
      this.pipingService.stopGateValveMode();
      this.pipingService.stopGateValveSMode();
      this.pipingService.stopGateValveFLMode();
      this.pipingService.stopGlobeValveSMode();
      this.pipingService.stopGlobeValveFLMode();
      this.pipingService.stopBallValveSMode();
      this.pipingService.stopBallValveFLMode();
      this.isometryToolsService.stopSlopeMode();
      this.freehandDrawingService.stopFreehandDrawing();
      console.log('Calling lineDrawingService.setDrawingMode with:', mode);
      this.lineDrawingService.setDrawingMode(mode);
      console.log('lineDrawingService.drawingMode is now:', this.lineDrawingService.drawingMode);
    }
  }

  public handleMouseDown(options: any): void {
    if (this.weldingService.isActive()) {
      this.weldingService.handleMouseDown(options);
      return;
    }

    if (this.pipingService.isActive()) {
      this.pipingService.handleMouseDown(options);
      return;
    }
    
    if (this.isometryToolsService.isSlopeModeActive()) {
      this.isometryToolsService.handleMouseDown(this.canvas, options);
      return;
    }
    
    // Handle Move Pipe Mode
    if (this.lineDrawingService.drawingMode === 'movePipe') {
      this.lineDrawingService.handleMovePipeMouseDown(this.canvas, options);
      return;
    }

    // Check if freehand mode is active
    if (this.freehandDrawingService && this.freehandDrawingService.isActive()) {
      // Freehand drawing is handled separately by its own service
      return;
    }

    const drawingMode = this.lineDrawingService.drawingMode;

    if (drawingMode === 'dimension') {
      const editablePipes = this.lineDrawingService.getEditablePipes();
      const editableLines = this.lineDrawingService.getEditableLines();
      this.dimensionService.handleDimensionMouseDown(this.canvas, options, editablePipes, editableLines);
      return;
    }

    if (drawingMode === 'text') {
      this.objectManagementService.addText(this.canvas, options);
      this.lineDrawingService.setDrawingMode('idle');
      return;
    }

    if (drawingMode === 'spool') {
      this.objectManagementService.addSpoolText(this.canvas, options);
      return;
    }

    // Handle test line mode
    if (this.lineDrawingService.drawingMode === 'testLine') {
      this.lineDrawingService.handleTestLineMouseDown(this.canvas, options);
      return;
    }
    
    this.lineDrawingService.handleLineMouseDown(this.canvas, options);
    this.lineDrawingService.handlePipeMouseDown(this.canvas, options);
  }

  public handleMouseUp(options: any): void {
    // Handle Move Pipe Mode
    if (this.lineDrawingService.drawingMode === 'movePipe') {
      this.lineDrawingService.handleMovePipeMouseUp(this.canvas, options);
      return;
    }
    
    // Handle T-Stück/Ventil final position update
    if (options.target && (options.target as any).originalLineCoords) {
      const component = options.target;
      
      // Lösche temporäre Daten nach der Bewegung
      delete (component as any).originalLineCoords;
      delete (component as any).initialMovePosition;
      
      // Speichere den finalen Zustand
      if (this.stateManagementService) {
        this.stateManagementService.saveState('Move T-Stück/Ventil');
      }
      
      // Render Canvas
      if (this.canvas) {
        this.canvas.requestRenderAll();
      }
    }
  }

  public handleMouseMove(options: any): void {
    if (this.weldingService.isActive()) {
      this.weldingService.handleMouseMove(options);
      return;
    }

    if (this.pipingService.isActive()) {
      this.pipingService.handleMouseMove(options);
      return;
    }
    
    if (this.isometryToolsService.isSlopeModeActive()) {
      this.isometryToolsService.handleMouseMove(this.canvas, options);
      return;
    }
    
    // Handle Move Pipe Mode
    if (this.lineDrawingService.drawingMode === 'movePipe') {
      this.lineDrawingService.handleMovePipeMouseMove(this.canvas, options);
      return;
    }

    // Check if freehand mode is active
    if (this.freehandDrawingService && this.freehandDrawingService.isActive()) {
      // Freehand drawing is handled separately by its own service
      return;
    }

    const drawingMode = this.lineDrawingService.drawingMode;

    if (drawingMode === 'dimension') {
      this.dimensionService.handleDimensionMouseMove(this.canvas, options);
      return;
    }
    
    // Handle test line mode
    if (drawingMode === 'testLine') {
      this.lineDrawingService.handleTestLineMouseMove(this.canvas, options);
      return;
    }

    this.lineDrawingService.handleLineMouseMove(this.canvas, options);
    this.lineDrawingService.handlePipeMouseMove(this.canvas, options);
    // Use debounced render for mouse move operations
    this.renderScheduler.debouncedRender(this.canvas);
  }

  public handleDoubleClick(options: fabric.TEvent<MouseEvent>): void {
    this.lineDrawingService.handlePipeDoubleClick(this.canvas, options);
    
    // Prüfe, ob ein Bemaßungstext oder Gefälle-Text doppelgeklickt wurde
    const target = (options as any).target;
    if (target) {
      // Prüfe direkt auf Bemaßungstext oder Gefälle-Text
      if (target.type === 'i-text' && ((target as any).customType === 'dimensionText' || (target as any).customType === 'slopeText')) {
        const textObject = target as fabric.IText;
        // Aktiviere den Text zum Bearbeiten
        this.canvas.setActiveObject(textObject);
        textObject.enterEditing();
        textObject.selectAll();
      }
      // Prüfe auch Gruppen für Gefälle-Marker - Bearbeite Text direkt ohne Entgruppierung
      else if (target.type === 'group' && (target as any).customType === 'slopeMarker') {
        // Zeige Dialog zum Bearbeiten des Gefälle-Werts
        const currentValue = (target as any).slopeData?.percent || '0.50';
        const newValue = prompt('Gefälle in % ändern:', currentValue);
        
        if (newValue !== null && newValue !== currentValue) {
          // Aktualisiere den Text in der Gruppe
          const group = target as fabric.Group;
          const objects = group.getObjects();
          const textObj = objects.find((obj: any) => obj.type === 'i-text' && obj.customType === 'slopeText');
          
          if (textObj) {
            (textObj as fabric.IText).set('text', `Gefälle ${newValue}%`);
            (target as any).slopeData.percent = newValue;
            this.canvas.requestRenderAll();
          }
        }
      }
    }
  }

  public handleSelectionCreated(e: any): void {
    // Handle selection events if needed
  }

  public handleSelectionCleared(): void {
    // Handle selection cleared events if needed
  }

  public handleObjectMoving(e: any) {
    const movedObject = e.target;
    
    // Prüfe ob es ein T-Stück oder Ventil mit Ankerpunkten ist
    if (movedObject && (movedObject as any).customType) {
      const customType = (movedObject as any).customType;
      
      // Behandle T-Stück, Ventile mit Ankerpunkten
      if (customType === 'teeJoint' || customType === 'gateValveS' || customType === 'gateValveFL') {
        // Prüfe ob das Objekt verbundene Linien hat (auf einer Pipe platziert)
        const connectedLines = (movedObject as any).connectedLines;
        console.log('Moving component:', customType, 'Connected lines:', connectedLines);
        
        if (connectedLines && connectedLines.length > 0) {
          // Speichere die initiale Position beim ersten Bewegungsaufruf
          if (!(movedObject as any).initialMovePosition) {
            console.log('Saving initial position:', movedObject.left, movedObject.top);
            (movedObject as any).initialMovePosition = {
              left: movedObject.left,
              top: movedObject.top
            };
          }
          this.constrainComponentToLine(movedObject, e);
        } else {
          console.log('No connected lines, using free movement');
          this.moveComponentWithAnchors(movedObject, e);
        }
        return;
      }
    }
    
    this.lineDrawingService.handleObjectMoving(this.canvas, e);
  }
  
  private constrainComponentToLine(component: fabric.Object, e: any): void {
    if (!this.canvas) return;
    
    const connectedLines = (component as any).connectedLines;
    
    console.log('constrainComponentToLine called:', {
      connectedLines: connectedLines,
      connectedLinesLength: connectedLines?.length,
      componentType: (component as any).customType,
      hasOriginalLineCoords: !!(component as any).originalLineCoords
    });
    
    if (!connectedLines || connectedLines.length < 2) {
      // Fallback auf normale Bewegung
      console.log('Falling back to free movement - no lines found');
      this.moveComponentWithAnchors(component, e);
      return;
    }
    
    // Speichere die ursprüngliche Linie beim ersten Mal
    if (!(component as any).originalLineCoords) {
      // Rekonstruiere die ursprüngliche Linie aus den beiden Teilen
      const line1 = connectedLines[0];
      const line2 = connectedLines[1];
      
      // Extrahiere Start- und Endpunkt der gesamten ursprünglichen Linie
      let startX, startY, endX, endY;
      
      // Line1 Startpunkt
      if (line1.x1 !== undefined) {
        startX = line1.x1;
        startY = line1.y1;
      } else if (line1.getCoords) {
        const coords = line1.getCoords();
        if (coords.length >= 2) {
          startX = coords[0].x;
          startY = coords[0].y;
        }
      }
      
      // Line2 Endpunkt  
      if (line2.x2 !== undefined) {
        endX = line2.x2;
        endY = line2.y2;
      } else if (line2.getCoords) {
        const coords = line2.getCoords();
        if (coords.length >= 2) {
          endX = coords[1].x;
          endY = coords[1].y;
        }
      }
      
      if (startX !== undefined && endX !== undefined) {
        (component as any).originalLineCoords = {
          startX, startY, endX, endY
        };
        console.log('Saved original line coords:', (component as any).originalLineCoords);
      } else {
        console.log('Could not extract line coordinates');
        this.moveComponentWithAnchors(component, e);
        return;
      }
    }
    
    // Verwende die gespeicherten Linien-Koordinaten
    const lineCoords = (component as any).originalLineCoords;
    const lineStart = { x: lineCoords.startX, y: lineCoords.startY };
    const lineEnd = { x: lineCoords.endX, y: lineCoords.endY };
    
    // Aktuelle Mausposition
    const pointer = this.canvas.getPointer(e.e);
    
    // Projiziere die Mausposition auf die Linie
    const projection = this.projectPointOntoLine(pointer, lineStart, lineEnd);
    
    // Beschränke die Position auf die Linie (mit etwas Puffer an den Enden)
    const minT = 0.1; // 10% vom Anfang
    const maxT = 0.9; // 90% vom Ende
    const clampedT = Math.max(minT, Math.min(maxT, projection.t));
    
    // Berechne die neue Position auf der Linie
    const newX = lineStart.x + (lineEnd.x - lineStart.x) * clampedT;
    const newY = lineStart.y + (lineEnd.y - lineStart.y) * clampedT;
    
    // Setze die Position des T-Stücks (Gruppe)
    component.set({
      left: newX,
      top: newY
    });
    component.setCoords();
    
    // Aktualisiere die Linien SOFORT für visuelles Feedback
    this.updateConnectedLinesImmediately(component, newX, newY);
    
    // Aktualisiere die Ankerpunkte an den neuen Linienenden
    this.updateComponentAnchorsOnLines(component, connectedLines);
    
    // Canvas neu rendern
    this.canvas.requestRenderAll();
  }
  
  private updateConnectedLinesImmediately(component: fabric.Object, newX: number, newY: number): void {
    const connectedLines = (component as any).connectedLines;
    if (!connectedLines || connectedLines.length < 2) return;
    
    const line1 = connectedLines[0];
    const line2 = connectedLines[1];
    
    // Aktualisiere den Endpunkt von line1 zur neuen T-Stück Position
    if (line1) {
      if (line1.set) {
        line1.set({ x2: newX, y2: newY });
      }
      if (line1.x2 !== undefined) {
        line1.x2 = newX;
        line1.y2 = newY;
      }
      if (line1.setCoords) line1.setCoords();
    }
    
    // Aktualisiere den Startpunkt von line2 zur neuen T-Stück Position
    if (line2) {
      if (line2.set) {
        line2.set({ x1: newX, y1: newY });
      }
      if (line2.x1 !== undefined) {
        line2.x1 = newX;
        line2.y1 = newY;
      }
      if (line2.setCoords) line2.setCoords();
    }
  }
  
  private updateComponentAnchorsOnLines(component: fabric.Object, connectedLines: any[]): void {
    if (!this.canvas || !connectedLines || connectedLines.length < 2) return;
    
    const componentId = (component as any).customId;
    if (!componentId) return;
    
    // Finde alle Ankerpunkte des T-Stücks
    const anchors = this.canvas.getObjects().filter(obj => 
      (obj as any).isAnchor && (obj as any).componentId === componentId
    );
    
    if (anchors.length < 3) return; // T-Stück hat 3 Ankerpunkte
    
    const line1 = connectedLines[0];
    const line2 = connectedLines[1];
    const teeData = (component as any).teeData || {};
    const angle = teeData.angle || 0;
    const mirrored = teeData.mirrored || false;
    const flipped = teeData.flipped || false;
    const centerX = component.left!;
    const centerY = component.top!;
    
    // Berechne die tatsächliche Rotation
    let teeAngle = angle;
    if (mirrored) {
      teeAngle += 180;
    }
    const angleRad = (teeAngle * Math.PI) / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    
    // Konstanten für T-Stück Geometrie
    const segmentLength = 20;
    const branchLength = 25;
    const branchAngle = flipped ? -60 : 60;
    
    // Ankerpunkt 0: Links auf der Hauptlinie
    const leftX = centerX - segmentLength * cos;
    const leftY = centerY - segmentLength * sin;
    
    // Ankerpunkt 1: Rechts auf der Hauptlinie
    const rightX = centerX + segmentLength * cos;
    const rightY = centerY + segmentLength * sin;
    
    // Ankerpunkt 2: Abzweig
    const branchRad = ((90 + branchAngle) * Math.PI) / 180;
    const branchEndXLocal = branchLength * Math.cos(branchRad);
    const branchEndYLocal = branchLength * Math.sin(branchRad);
    const branchX = centerX + (branchEndXLocal * cos - branchEndYLocal * sin);
    const branchY = centerY + (branchEndXLocal * sin + branchEndYLocal * cos);
    
    // Setze die Ankerpunkt-Positionen
    if (anchors[0]) {
      anchors[0].set({ left: leftX, top: leftY });
      anchors[0].setCoords();
    }
    if (anchors[1]) {
      anchors[1].set({ left: rightX, top: rightY });
      anchors[1].setCoords();
    }
    if (anchors[2]) {
      anchors[2].set({ left: branchX, top: branchY });
      anchors[2].setCoords();
    }
  }
  
  private projectPointOntoLine(point: { x: number, y: number }, lineStart: { x: number, y: number }, lineEnd: { x: number, y: number }): { x: number, y: number, t: number } {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lengthSquared = dx * dx + dy * dy;
    
    if (lengthSquared === 0) {
      return { x: lineStart.x, y: lineStart.y, t: 0 };
    }
    
    // Berechne t (Position auf der Linie von 0 bis 1)
    const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lengthSquared;
    
    // Projizierter Punkt
    const projectedX = lineStart.x + t * dx;
    const projectedY = lineStart.y + t * dy;
    
    return { x: projectedX, y: projectedY, t: t };
  }
  
  
  private moveComponentWithAnchors(component: fabric.Object, e: any): void {
    if (!this.canvas) return;
    
    const customType = (component as any).customType;
    const componentId = (component as any).customId || (component as any).teeId;
    if (!componentId) return;
    
    // Finde alle Ankerpunkte, die zu diesem Component gehören
    const anchors = this.canvas.getObjects().filter(obj => 
      (obj as any).isAnchor && ((obj as any).componentId === componentId || (obj as any).teeId === componentId)
    );
    
    // Für T-Stücke: finde auch die zugehörigen Linien
    let teeLines: fabric.Object[] = [];
    if (customType === 'teeJoint') {
      teeLines = this.canvas.getObjects().filter(obj => 
        (obj as any).teeId === componentId && (obj as any).teePart
      );
    }
    
    // Berechne die Bewegung relativ zur Komponente
    const centerPoint = component.getCenterPoint();
    
    // Für T-Stücke: Berechne neue Positionen basierend auf der neuen Zentrumsposition
    if (customType === 'teeJoint') {
      const newX = centerPoint.x;
      const newY = centerPoint.y;
      const teeData = (component as any).teeData;
      const angle = teeData?.angle || 0;
      const angleRad = (angle * Math.PI) / 180;
      const cos = Math.cos(angleRad);
      const sin = Math.sin(angleRad);
      
      const segmentLength = 20;
      const branchLength = 25;
      const branchAngle = teeData?.flipped ? -60 : 60;
      const branchRad = ((90 + branchAngle) * Math.PI) / 180;
      const branchEndXLocal = branchLength * Math.cos(branchRad);
      const branchEndYLocal = branchLength * Math.sin(branchRad);
        
        if (anchorIndex === 0) {
          // Linker Ankerpunkt
          offsetX = -segmentLength * Math.cos(angleRad);
          offsetY = -segmentLength * Math.sin(angleRad);
        } else if (anchorIndex === 1) {
          // Rechter Ankerpunkt
          offsetX = segmentLength * Math.cos(angleRad);
          offsetY = segmentLength * Math.sin(angleRad);
        } else if (anchorIndex === 2) {
          // Abzweig-Ankerpunkt
          const branchRad = ((90 + branchAngle) * Math.PI) / 180;
          const branchEndX = branchLength * Math.cos(branchRad);
          const branchEndY = branchLength * Math.sin(branchRad);
          offsetX = branchEndX * Math.cos(angleRad) - branchEndY * Math.sin(angleRad);
          offsetY = branchEndX * Math.sin(angleRad) + branchEndY * Math.cos(angleRad);
        }
      } else if (customType === 'gateValveS' || customType === 'gateValveFL') {
        // Ventile haben 2 Ankerpunkte
        const distance = customType === 'gateValveFL' ? 20 : 16;
        
        if (anchorIndex === 0) {
          // Erster Ankerpunkt
          offsetX = -distance * Math.cos(angleRad);
          offsetY = -distance * Math.sin(angleRad);
        } else {
          // Zweiter Ankerpunkt
          offsetX = distance * Math.cos(angleRad);
          offsetY = distance * Math.sin(angleRad);
        }
      }
      
      // Setze neue Position
      anchor.set({
        left: groupCenter.x + offsetX,
        top: groupCenter.y + offsetY
      });
      anchor.setCoords();
    });
    
    // Rendere Canvas neu
    this.canvas.requestRenderAll();
  }
  
  public updateComponentAnchors(component: fabric.Object): void {
    // Öffentliche Methode für die Canvas-Komponente
    this.moveComponentWithAnchors(component, null);
  }

  public cancelDrawing(): void {
    this.lineDrawingService.cancelDrawing(this.canvas);
    // Stop dimension mode if active
    if (this.dimensionService.getDimensionStep()) {
      this.dimensionService.resetAnchorHighlights(this.canvas);
      this.dimensionService.stopDimensioning();
      this.dimensionService.clearTemporaryDimensionAnchors(this.canvas);
    }
    // Deselect any active object and clear top context
    if (this.canvas) {
      this.canvas.discardActiveObject();
      // Clear the top context to remove any selection artifacts
      const topCtx = this.canvas.contextTop;
      if (topCtx) {
        topCtx.clearRect(0, 0, this.canvas.width!, this.canvas.height!);
      }
      this.canvas.requestRenderAll();
    }
  }

  public groupSelectedObjects(): void {
    this.objectManagementService.groupSelectedObjects(this.canvas);
  }

  public ungroupObjects(): void {
    this.objectManagementService.ungroupObjects(this.canvas);
  }

  public deleteSelectedObjects(): void {
    this.objectManagementService.deleteSelectedObjects(this.canvas);
  }


  public addAnchors(): void {
    this.setDrawingMode('addAnchors');
  }

  // Getter for drawing mode to maintain compatibility
  public get drawingMode(): DrawingMode {
    const weldingMode = this.weldingService.getActiveMode();
    if (weldingMode) {
      return weldingMode;
    }
    if (this.pipingService.isFlowModeActive()) {
      return 'flow';
    }
    if (this.pipingService.isGateValveModeActive()) {
      return 'gateValve';
    }
    if (this.pipingService.isGateValveSModeActive()) {
      return 'gateValveS';
    }
    if (this.pipingService.isGateValveFLModeActive()) {
      return 'gateValveFL';
    }
    if (this.pipingService.isGlobeValveSModeActive()) {
      return 'globeValveS';
    }
    if (this.pipingService.isGlobeValveFLModeActive()) {
      return 'globeValveFL';
    }
    if (this.pipingService.isBallValveSModeActive()) {
      return 'ballValveS';
    }
    if (this.pipingService.isBallValveFLModeActive()) {
      return 'ballValveFL';
    }
    if (this.pipingService.isTeeJointModeActive()) {
      return 'teeJoint';
    }
    if (this.isometryToolsService.isSlopeModeActive()) {
      return 'slope';
    }
    if (this.freehandDrawingService && this.freehandDrawingService.isActive()) {
      return 'freehand';
    }
    return this.lineDrawingService.drawingMode as any;
  }

  public set drawingMode(mode: 'idle' | 'addLine' | 'addPipe' | 'dimension' | 'text' | 'addAnchors' | 'weldstamp' | 'welderstamp' | 'welderstampempty' | 'welderstampas' | 'weld' | 'fluidstamp' | 'spool' | 'flow' | 'gateValve' | 'gateValveS' | 'gateValveFL' | 'globeValveS' | 'globeValveFL' | 'ballValveS' | 'ballValveFL' | 'slope' | 'testLine' | 'freehand') {
    if (mode === 'weldstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWeldstamp();
    } else if (mode === 'welderstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStamp();
    } else if (mode === 'welderstampempty') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStampEmpty();
    } else if (mode === 'welderstampas') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWelderStampAS();
    } else if (mode === 'weld') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startWeld();
    } else if (mode === 'fluidstamp') {
      this.lineDrawingService.setDrawingMode('idle');
      this.weldingService.startFluidStamp();
    } else if (mode === 'flow') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startFlowMode();
    } else if (mode === 'gateValve') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveMode();
    } else if (mode === 'gateValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveSMode();
    } else if (mode === 'gateValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGateValveFLMode();
    } else if (mode === 'globeValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGlobeValveSMode();
    } else if (mode === 'globeValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startGlobeValveFLMode();
    } else if (mode === 'ballValveS') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startBallValveSMode();
    } else if (mode === 'ballValveFL') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startBallValveFLMode();
    } else if ((mode as any) === 'teeJoint') {
      this.lineDrawingService.setDrawingMode('idle');
      this.pipingService.startTeeJointMode();
    } else if (mode === 'slope') {
      this.lineDrawingService.setDrawingMode('idle');
      this.isometryToolsService.startSlopeMode();
    } else if (mode === 'testLine') {
      this.lineDrawingService.setDrawingMode('testLine');
    } else if (mode === 'freehand') {
      this.lineDrawingService.setDrawingMode('idle');
      this.freehandDrawingService.startFreehandDrawing();
    } else {
      this.weldingService.stopWeldstamp();
      this.weldingService.stopWelderStamp();
      this.weldingService.stopWelderStampEmpty();
      this.weldingService.stopWelderStampAS();
      this.weldingService.stopWeld();
      this.weldingService.stopFluidStamp();
      this.pipingService.stopFlowMode();
      this.pipingService.stopGateValveMode();
      this.pipingService.stopGateValveSMode();
      this.pipingService.stopTeeJointMode();
      this.pipingService.stopGateValveFLMode();
      this.pipingService.stopGlobeValveSMode();
      this.pipingService.stopGlobeValveFLMode();
      this.pipingService.stopBallValveSMode();
      this.pipingService.stopBallValveFLMode();
      this.isometryToolsService.stopSlopeMode();
      this.freehandDrawingService.stopFreehandDrawing();
      this.lineDrawingService.setDrawingMode(mode);
    }
  }

  public get pipePoints(): { x: number; y: number }[] {
    return this.lineDrawingService['pipePoints'];
  }

  public set pipePoints(points: { x: number; y: number }[]) {
    this.lineDrawingService['pipePoints'] = points;
  }
  
  // Color mode methods
  public setColorMode(mode: 'drawing' | 'blackwhite' | 'norm'): void {
    console.log('Setting color mode to:', mode);
    this.colorMode = mode;
    this.updateCanvasColors();
  }
  
  public getColor(element: 'line' | 'pipe' | 'dimension' | 'text' | 'weld' | 'anchor' | 'valve'): string {
    return this.colorSchemes[this.colorMode][element];
  }
  
  private updateCanvasColors(): void {
    if (!this.canvas) return;
    
    const objects = this.canvas.getObjects();
    objects.forEach(obj => {
      // Update line colors
      if (obj instanceof fabric.Line) {
        // Store original type if not already stored
        if ((obj as any).isPipe === undefined && obj.stroke === 'green') {
          (obj as any).isPipe = true;
        }
        
        if ((obj as any).isPipe) {
          obj.set('stroke', this.getColor('pipe'));
        } else if ((obj as any).isDimensionPart) {
          obj.set('stroke', this.getColor('dimension'));
        } else {
          obj.set('stroke', this.getColor('line'));
        }
      }
      // Update path colors (for pipes)
      else if (obj instanceof fabric.Path) {
        if ((obj as any).isPipe || obj.stroke === 'green' || obj.stroke === '#00A050' || obj.stroke === 'black') {
          // Always update pipe colors based on current mode
          if ((obj as any).isPipe !== false) {  // Check if it's a pipe
            obj.set('stroke', this.getColor('pipe'));
          }
        }
      }
      // Update circle colors (anchors)
      else if (obj instanceof fabric.Circle) {
        if ((obj as any).customType === 'anchorPoint') {
          // Store original colors if not already stored
          if (!(obj as any).originalFill) {
            (obj as any).originalFill = obj.fill;
            (obj as any).originalStroke = obj.stroke;
          }
          
          // Check original colors to determine point type
          const origFill = (obj as any).originalFill;
          const origStroke = (obj as any).originalStroke;
          
          if (origFill === 'blue' || origStroke === 'blue' || origStroke === 'darkblue' || 
              (typeof origFill === 'string' && origFill.includes('rgba(0, 0, 255')) ||
              (typeof origStroke === 'string' && origStroke.includes('rgba(0, 0, 139'))) {
            // Blue anchor points
            if (this.colorMode === 'blackwhite') {
              obj.set({
                'fill': 'black',
                'stroke': 'black'
              });
            } else if (this.colorMode === 'norm') {
              obj.set({
                'fill': '#0000FF',
                'stroke': '#00008B'
              });
            } else {
              // Drawing mode - restore original transparent blue
              if (typeof origFill === 'string' && origFill.includes('rgba')) {
                obj.set({
                  'fill': 'rgba(0, 0, 255, 0.2)',
                  'stroke': 'rgba(0, 0, 139, 0.4)'
                });
              } else {
                obj.set({
                  'fill': 'blue',
                  'stroke': 'darkblue'
                });
              }
            }
          } else if (origFill === 'red' || origStroke === 'red' || origStroke === 'darkred') {
            // Red anchor points
            if (this.colorMode === 'blackwhite') {
              obj.set({
                'fill': 'black',
                'stroke': 'black'
              });
            } else {
              // Restore original red colors
              obj.set({
                'fill': origFill || 'red',
                'stroke': origStroke || 'darkred'
              });
            }
          } else if (origFill === 'transparent' || !origFill) {
            // Transparent anchor points
            obj.set({
              'fill': 'transparent',
              'stroke': this.getColor('anchor')
            });
          }
        }
      }
      // Update text colors
      else if (obj instanceof fabric.IText || obj instanceof fabric.Text) {
        if (!(obj as any).isDimensionPart) {
          obj.set('fill', this.getColor('text'));
        } else {
          obj.set('fill', this.getColor('dimension'));
        }
      }
      // Update group colors
      else if (obj instanceof fabric.Group) {
        if ((obj as any).isWeldPoint || (obj as any).customType?.includes('weld')) {
          obj.getObjects().forEach((subObj: any) => {
            if (subObj.type === 'line') {
              subObj.set('stroke', this.getColor('weld'));
            }
          });
        } else if ((obj as any).customType?.includes('valve')) {
          obj.getObjects().forEach((subObj: any) => {
            if (subObj.type === 'line' || subObj.type === 'path') {
              subObj.set('stroke', this.getColor('valve'));
            }
          });
        }
      }
    });
    
    this.canvas.requestRenderAll();
  }
}
